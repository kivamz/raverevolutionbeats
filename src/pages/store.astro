---
import Layout from '../components/Layout.astro';
import "../styles/store.scss";

// Interfaces para tipar productos y sus variantes.
// Ajusta los campos según la respuesta real de la API de Printful.
interface Product {
  id: number;
  name: string;
  thumbnail_url?: string;
  description?: string;
}

interface Variant {
  id: number | string;
  name: string;
  retail_price?: string; // Precio recomendado, si lo entrega la API
  price?: string;        // Alternativa si existiera
}

interface ProductDetail extends Product {
  variants: Variant[];
}

const PRINTFUL_API_BASE = import.meta.env.PRINTFUL_API_BASE;
const PRINTFUL_ACCESS_TOKEN = import.meta.env.PRINTFUL_ACCESS_TOKEN;

if (!PRINTFUL_ACCESS_TOKEN) {
  throw new Error("Printful access token is not defined. Revisa tu archivo .env.");
}

let products: Product[] = [];

// Llamada al endpoint para obtener la lista de productos.
const endpoint = `${PRINTFUL_API_BASE}store/products`;

try {
  const response = await fetch(endpoint, {
    headers: {
      'Authorization': `Bearer ${PRINTFUL_ACCESS_TOKEN}`,
      'Content-Type': 'application/json'
    }
  });
  if (!response.ok) {
    console.error("Printful API response error:", response.statusText);
  } else {
    const productsData = await response.json();
    products = productsData.result || [];
  }
} catch (error) {
  console.error('Error fetching products:', error);
}

let detailedProducts: ProductDetail[] = [];

if (products.length > 0) {
  detailedProducts = await Promise.all(
    products.map(async (prod: Product) => {
      try {
        const resDetail = await fetch(`${PRINTFUL_API_BASE}store/products/${prod.id}`, {
          headers: {
            'Authorization': `Bearer ${PRINTFUL_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });
        if (resDetail.ok) {
          const detailData = await resDetail.json();
          console.log(`Detail for product ${prod.id}:`, detailData);
          if (detailData && detailData.result && (detailData.result.variants || detailData.result.sync_variants)) {
            const variants = detailData.result.variants || detailData.result.sync_variants;
            return { ...prod, variants } as ProductDetail;
          } else {
            console.error(`No variants found for product ${prod.id}`, detailData);
            return { ...prod, variants: [] } as ProductDetail;
          }
        } else {
          console.error("Error fetching product detail for", prod.id, resDetail.statusText);
          return { ...prod, variants: [] } as ProductDetail;
        }
      } catch (error) {
        console.error("Error fetching product detail for", prod.id, error);
        return { ...prod, variants: [] } as ProductDetail;
      }
    })
  );
}

const formatEuro = (value: number) =>
  new Intl.NumberFormat('es-ES', {
    style: 'currency',
    currency: 'EUR'
  }).format(value);

const slugify = (str: string): string =>
  str
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
---
<Layout>
  <section class="store">
    <div class="container">
      <h1>Our Store</h1>
      <p>Discover our exclusive collection of products.</p>
      <div class="products">
        {detailedProducts.map((product: ProductDetail) => (
          <a 
            class="product-link" 
            href={`store/product/${product.id}-${slugify(product.name)}`} 
            data-key={product.id}
          >
            <div class="product">
              {product.thumbnail_url && (
                <img src={product.thumbnail_url} alt={product.name} />
              )}
              <div class="product-content">
                <h2>{product.name}</h2>
                {product.description && <p>{product.description}</p>}
                {product.variants && product.variants.length > 0 && (
                  (() => {
                    // Extraemos los precios de las variantes.
                    const prices = product.variants
                      .map(v => {
                        // Primero intentamos con "retail_price"; si no es válido, usamos "price".
                        let p = parseFloat(v.retail_price || '');
                        if (isNaN(p)) {
                          p = parseFloat(v.price || '');
                        }
                        return p;
                      })
                      .filter(p => !isNaN(p));

                    if (prices.length === 0) return <p class="price">Price not available</p>;

                    const min = Math.min(...prices);
                    const max = Math.max(...prices);
                    if (min === max) {
                      return <p class="price">{formatEuro(min)}</p>;
                    } else {
                      return <p class="price">From {formatEuro(min)} to {formatEuro(max)}</p>;
                    }
                  })()
                )}
              </div>
            </div>
          </a>
        ))}
      </div>
    </div>
  </section>
</Layout>
